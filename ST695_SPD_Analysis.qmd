---
title: "ST695_SPD_Analysis"
format: latex
editor: visual
date: today
---

**Instantiate Libraries**
```{r}
library(lmerTest) #For REML Analysis
library(afex) #For ANOVA Analysis
library(FrF2) #For QQ Plots
library(BsMD) #For Lenth Plots
```

**Import SP PLA Data Set **
```{r Import and Preprocess SP Data}
Ys_data <- read.csv("Data/YsData.csv")
Ys_data <- Ys_data[,7:13]
Ys_data$WP=as.factor(Ys_data$WP)
cat("SP PLA Data Set\n")
print(Ys_data)
```

**Method 1 (Ordinary Least Squares)**
```{r S Model by OLS}
WP_factors <- colnames(Ys_data[1:3])
SP_factors <- colnames(Ys_data[4:5])
linear_terms <- c(WP_factors, SP_factors)
# Model with all main effects and 2-way interactions
formula_1 <- as.formula(paste("Y_S ~ (", 
    paste(linear_terms, collapse = " + "),")^2"))
Method_1 <- summary(lm(formula_1, data = Ys_data))
Method_1
```

Residual Standard Error: 49.74. Error variance estimate: 49.74\^2 = 2474.8

The error variance (mean squared error, MSE) is 2474.8 in your model. This value is the estimate of the residual variance from your standard linear model.

**Method 2A (Restricted Maximum Likelihood using Satterwaithe)**
```{r S Model by REML  (Satterwaithe t-tests)}
# Model with all main effects, 2-way interactions, and random WP effect
formula_2A <- as.formula(paste("Y_S ~ (", 
    paste(linear_terms, collapse = " + "),")^2 + (1|WP)"))
Method_2A <- summary(lmer(formula_2A, data = Ys_data))
Method_2A
```
**Method 2B (Restricted Maximum Likelihood using Kenward Roger)**
```{r}
# Model with all main effects, 2-way interactions, and random WP effect
formula_2B <- as.formula(paste("Y_S ~ (", 
    paste(linear_terms, collapse = " + "),")^2+ (1|WP)"))
# Fit model with Kenward-Roger method
model_2B <- lmer(formula_2B, data = Ys_data, REML = TRUE)
Method_2B <- summary(model_2B, ddf = "Kenward-Roger")
Method_2B
```

**Method 4A ANOVA using Base R**
```{r S Model by ANOVA}
# Model with all main effects, 2-way interactions,
#and split-plot error structure
formula_4A <- as.formula(paste("Y_S ~ (", 
    paste(linear_terms, collapse = " + "),")^2 + Error(WP)"))
Method_4A <- summary(aov(formula_4A, data = Ys_data))
Method_4A
```

**Method 4B ANOVA using Letsinger**
```{r S Model by ANOVA using Letsinger}

# Proposed ANOVA method: saturated model with all 2-way + T:P:S interaction

library(readr)

data <- read_csv("Data/PLA_Data.csv")

# Saturated model: all 2-way interactions + T:P:S
saturated_formula <- "Denier ~ (T + P + S + D + R)^2 + T:P:S"
saturated_model <- lm(saturated_formula, data = data)

# Reduced model: T + P + S + D + R + P:S + P:D + S:D
reduced_formula <- "Denier ~ T + P + S + D + R + P:S + P:D + S:D"
reduced_model <- lm(reduced_formula, data = data)

# Calculate sums of squares and degrees of freedom
SS_saturated <- sum(residuals(saturated_model)^2)
SS_reduced <- sum(residuals(reduced_model)^2)
df_saturated <- saturated_model$df.residual
df_reduced <- reduced_model$df.residual

MSsp <- SS_saturated / df_saturated
MSdif <- (SS_reduced - SS_saturated) / (df_reduced - df_saturated)
m <- 4
sigma2_wp <- (MSdif - MSsp) / m
sigma2_sp <- MSsp

cat("=== Proposed Method Results (Saturated model: 2-way + T:P:S) ===\n")
cat("Whole-plot error variance (σ²wp): ", round(sigma2_wp, 6), "\n")
cat("Sub-plot error variance (σ²sp):   ", round(sigma2_sp, 6), "\n")
cat("Total error variance:             ", round(sigma2_wp + sigma2_sp, 6), "\n")

if(!is.na(sigma2_wp) && sigma2_wp >= 0) {
  prop_wp <- sigma2_wp / (sigma2_wp + sigma2_sp) * 100
  prop_sp <- sigma2_sp / (sigma2_wp + sigma2_sp) * 100
  cat("Whole-plot error proportion: ", round(prop_wp, 1), "%\n")
  cat("Sub-plot error proportion:   ", round(prop_sp, 1), "%\n")
} else {
  cat("*** WARNING: Negative whole-plot variance estimate! ***\n")
  if(!is.na(sigma2_wp)) {
    prop_wp <- sigma2_wp / (sigma2_wp + sigma2_sp) * 100
    prop_sp <- sigma2_sp / (sigma2_wp + sigma2_sp) * 100
    cat("Whole-plot error proportion: ", round(prop_wp, 1), "%\n")
    cat("Sub-plot error proportion:   ", round(prop_sp, 1), "%\n")
  }
}

cat("\n=== Reduced Model Fixed Effects ===\n")
print(summary(reduced_model)$coefficients)

# Continue with any further analysis or reporting as needed
```


**Method 5A Additional Replicates**
```{r S Model with Additional Replicates, eval=FALSE}
# Function to simulate whole-plot and sub-plot replicates
WP_SP_replicates <- function(data, response = "Denier", r = 3, sd = 5, seed = 123) {
  set.seed(seed)
  # Repeat each row r times
  data_rep <- data[rep(1:nrow(data), each = r), ]
  # Add replicate identifier
  data_rep$RPL <- rep(1:r, times = nrow(data))
  # Add random noise to the response variable
  data_rep[[response]] <- data_rep[[response]] + rnorm(nrow(data_rep), mean = 0, sd = sd)
  rownames(data_rep) <- NULL
  return(data_rep)
}

# Function to calculate sub-plot variance (σ²_sp)
calculate_subplot_variance <- function(data, response, wp_col, sp_col) {
  # Split data by whole-plot column
  wp_groups <- split(data, data[[wp_col]])
  
  # Calculate variance within each whole-plot group
  sp_variances <- sapply(wp_groups, function(group) {
    sum((group[[response]] - mean(group[[response]]))^2) / (nrow(group) - 1)
  })
  
  # Return the average sub-plot variance
  sigma2_sp <- mean(sp_variances)
  return(sigma2_sp)
}

# Function to calculate total variance (σ²_tot)
calculate_total_variance <- function(data, response, replicate_col) {
  # Split data by replicate column
  replicate_groups <- split(data, data[[replicate_col]])
  
  # Calculate mean for each replicate group
  replicate_means <- sapply(replicate_groups, function(group) mean(group[[response]]))
  
  # Calculate variance of replicate means
  sigma2_tot <- var(replicate_means)
  return(sigma2_tot)
}

# Function to calculate whole-plot variance (σ²_wp)
calculate_wholeplot_variance <- function(sigma2_tot, sigma2_sp) {
  sigma2_wp <- sigma2_tot - sigma2_sp
  return(sigma2_wp)
}

# Main analysis function for Method 5A
method5A_analysis <- function(data, response = "Denier", wp_col = "WP", sp_col = "RPL", replicate_col = "RPL") {
  # Calculate sub-plot variance
  sigma2_sp <- calculate_subplot_variance(data, response, wp_col, sp_col)
  
  # Calculate total variance
  sigma2_tot <- calculate_total_variance(data, response, replicate_col)
  
  # Calculate whole-plot variance
  sigma2_wp <- calculate_wholeplot_variance(sigma2_tot, sigma2_sp)
  
  # Return results
  return(list(
    sigma2_sp = sigma2_sp,
    sigma2_tot = sigma2_tot,
    sigma2_wp = sigma2_wp
  ))
}

# Example usage


# Simulate replicates
replicated_data <- WP_SP_replicates(data = Ys_data, response = "Denier", r = 3, sd = 5, seed = 123)

# Perform Method 5A analysis
results <- method5A_analysis(replicated_data, response = "Denier", wp_col = "WP", sp_col = "RPL", replicate_col = "RPL")

# Print results
print(results)
```

**Method 5B Hierarchical Design**
```{r SModel with Hierarchical Design, eval=FALSE}
# Function to simulate hierarchical replicates for Method 5B
simulate_hierarchical_data <- function(data, response = "Denier", wp_col = "WP", 
                                       num_wp_replicates = 3, num_sp_replicates = 2, 
                                       sd_wp = 10, sd_sp = 5, seed = 123) {
  set.seed(seed)
  
  # Create whole-plot replicates
  wp_replicates <- data[rep(1:nrow(data), each = num_wp_replicates), ]
  wp_replicates$WP_Rep <- rep(1:num_wp_replicates, times = nrow(data))
  
  # Add random noise for whole-plot variability
  wp_replicates[[response]] <- wp_replicates[[response]] + 
    rnorm(nrow(wp_replicates), mean = 0, sd = sd_wp)
  
  # Create sub-plot replicates within each whole-plot replicate
  sp_replicates <- wp_replicates[rep(1:nrow(wp_replicates), each = num_sp_replicates), ]
  sp_replicates$SP_Rep <- rep(1:num_sp_replicates, times = nrow(wp_replicates))
  
  # Add random noise for sub-plot variability
  sp_replicates[[response]] <- sp_replicates[[response]] + 
    rnorm(nrow(sp_replicates), mean = 0, sd = sd_sp)
  
  # Reset row names and return the simulated dataset
  rownames(sp_replicates) <- NULL
  return(sp_replicates)
}

# Example usage

# Simulate hierarchical data
simulated_data <- simulate_hierarchical_data(
  data = Ys_data, 
  response = "Denier", 
  wp_col = "WP", 
  num_wp_replicates = 3,  # Number of whole-plot replicates
  num_sp_replicates = 2,  # Number of sub-plot replicates
  sd_wp = 10,             # Standard deviation for whole-plot noise
  sd_sp = 5,              # Standard deviation for sub-plot noise
  seed = 123              # Random seed for reproducibility
)

# View the first few rows of the simulated dataset
head(simulated_data)


# Function to perform Method 5B analysis
method5B_analysis <- function(data, response = "Denier", wp_col = "WP", wp_rep_col = "WP_Rep", sp_rep_col = "SP_Rep") {
  # Step 1: Calculate the total mean
  grand_mean <- mean(data[[response]])
  
  # Step 2: Calculate the whole-plot mean squares (MS_wp)
  wp_means <- aggregate(data[[response]], by = list(data[[wp_col]], data[[wp_rep_col]]), FUN = mean)
  colnames(wp_means) <- c(wp_col, wp_rep_col, "WP_Mean")
  wp_ms <- sum((wp_means$WP_Mean - grand_mean)^2) / (nrow(wp_means) - 1)
  
  # Step 3: Calculate the sub-plot mean squares (MS_sp)
  sp_means <- aggregate(data[[response]], by = list(data[[sp_rep_col]]), FUN = mean)
  colnames(sp_means) <- c(sp_rep_col, "SP_Mean")
  sp_ms <- sum((sp_means$SP_Mean - grand_mean)^2) / (nrow(sp_means) - 1)
  
  # Step 4: Calculate the residual mean squares (MS_res)
  residuals <- data[[response]] - ave(data[[response]], data[[wp_col]], data[[wp_rep_col]], data[[sp_rep_col]], FUN = mean)
  ms_res <- sum(residuals^2) / (nrow(data) - nrow(wp_means) - nrow(sp_means) + 1)
  
  # Step 5: Estimate variances
  sigma2_wp <- (wp_ms - sp_ms) / (length(unique(data[[wp_rep_col]])) * length(unique(data[[sp_rep_col]])))
  sigma2_sp <- (sp_ms - ms_res) / length(unique(data[[sp_rep_col]]))
  sigma2_res <- ms_res
  
  # Return results
  return(list(
    sigma2_wp = sigma2_wp,
    sigma2_sp = sigma2_sp,
    sigma2_res = sigma2_res
  ))
}

# Example usage

# Perform Method 5B analysis
results <- method5B_analysis(simulated_data, response = "Denier", wp_col = "WP", wp_rep_col = "WP_Rep", sp_rep_col = "SP_Rep")

# Print results
print(results)
```

**Method 6 QQ Plot Method for S Model**
```{r S Model with QQ Plot - 2 Plots}
# Model with all main effects and 2-way interactions
formula_6S <- as.formula(paste("Y_S ~ (", 
    paste(linear_terms, collapse = " + "),")^2"))
model_6S <- lm(formula_6S, data = Ys_data)  
effects <- coef(model_6S)[-1]   #Remove intercept
# Plot 1 - QQ Plot of SP Effects
SP_effects_names <- c(
  "D",    # SP main effect
  "R",    # SP main effect
  "D:R",  # SP interaction
  "T:D",  # SP x WP
  "T:R",  # SP x WP
  "P:D",  # SP x WP
  "P:R",  # SP x WP
  "S:D",  # SP x WP
  "S:R"   # SP x WP
)
SP_effects <- effects[SP_effects_names]
#Plot 2 - QQ Plot of WP Effects
WP_effects_names <- c(
  "T",    # WP main effect
  "S",    # WP main effect
  "P",    # WP main effect
  "T:S",  # WP interaction
  "T:P",  # WP interaction
  "P:S"   # WP interaction
)
WP_effects <- effects[WP_effects_names]
```

**Method 7 Lenth Method for S Model**
```{r S Model with Lenth Method - 2 Plots}
# Model with all main effects and 2-way interactions
formula_7S <- as.formula(paste("Y_S ~ (", 
    paste(linear_terms, collapse = " + "),")^2"))
model_7S <- lm(formula_7S, data = Ys_data)  # Use lm()
effects <- coef(model_7S)[-1]    # Remove intercept
# Plot 1 - Lenth Plot of SP Effects
SP_effects_names <- c(
  "D",    # SP main effect
  "R",    # SP main effect
  "D:R",  # SP interaction
  "T:D",  # SP x WP
  "T:R",  # SP x WP
  "P:D",  # SP x WP
  "P:R",  # SP x WP
  "S:D",  # SP x WP
  "S:R"   # SP x WP
)
SP_effects <- effects[SP_effects_names]
#Plot 2 - Lenth Plot of WP Effects
WP_effects_names <- c(
  "T",    # WP main effect
  "S",    # WP main effect
  "P",    # WP main effect
  "T:S",  # WP interaction
  "T:P",  # WP interaction
  "P:S"   # WP interaction
)
WP_effects <- effects[WP_effects_names]
```

**2 x 2 Plot of QQ and Lenth Plots for S Model
```{r 2x2 Plot for Section 1.2.4}
pdf("2x2_plot.pdf", width = 8, height = 8)
par(mfrow = c(2, 2))

# plot1 - WP QQ Plot
halfnormal(
  WP_effects,
  main = "Half-Normal Plot for S Model :\nWP Factors + 2-way Interactions",
  labs = WP_effects_names,
  alpha = 1
)

# plot2 - WP Lenth Plot
LenthPlot(WP_effects, main = "Lenth Plot for S Model: WP Effects")

# plot3 - SP QQ Plot
halfnormal(
  SP_effects,
  main = "Half-Normal Plot for S Model :\nSP Factors + 2-way Interactions +\n2-way Interactions with WP Factors",
  labs = SP_effects_names,
  alpha = 1
)
# plot4 - SP Lenth Plot
LenthPlot(SP_effects, main = "Lenth Plot for S Model: SP Effects")
dev.off()
```

**Import WP Factor PLA Data **
```{r Import and Preprocess WP Data}
Yw_data <- read.csv("Data/YwData.csv")
Yw_data <- Yw_data[,14:17]
cat("WP PLA Data Set\n")
print(Yw_data)
```

**Method 6 QQ Plot Method for W Model**
```{r W Model with QQ Plot}
# Model for WP factors (main effects, 2- and 3-way interactions)
formula_6W <- as.formula(paste("Y_W ~ (",
    paste(WP_factors, collapse = " + "),")^3"))
model_6W <- lm(formula_6W, data = Yw_data)
effects_6W <- coef(model_6W)[-1]
effect_names_6W <- names(coef(model_6W))[-1]
halfnormal(
  effects_6W,
  main = "Half-Normal Plot for W Model",
  labs = effect_names_6W,
  alpha = 1
)
```

```{r}

# Example: Half-Normal Plot with labels and reference line

set.seed(123)
effects <- rnorm(10, mean = 0, sd = 2)  # 10 random effects
effect_labels <- paste0("E", 1:10)

# Sort absolute effects and keep labels
order_idx <- order(abs(effects))
abs_effects <- abs(effects)[order_idx]
labels_sorted <- effect_labels[order_idx]

n <- length(effects)
expected <- qnorm((1:n - 0.5) / n) * sqrt(pi/2)

plot(expected, abs_effects,
     main = "Half-Normal Plot of Effects",
     xlab = "Absolute Effects",
     ylab = "Half-Normal Scores",
     pch = 19)

# Add labels to points
text(expected, abs_effects, labels = labels_sorted, pos = 3, cex = 0.8)


```




**Method 7 Lenth Method for W Model**
```{r W Model by Lenth Method}
# Model for WP factors (main effects, 2- and 3-way interactions)
formula_7W <- as.formula(paste("Y_W ~ (",
    paste(WP_factors, collapse = " + "),")^3"))
model_7W <- lm(formula_7W, data = Yw_data)
effects_7W <- coef(model_7W)[-1]  # Remove intercept
LenthPlot(effects_7W, main = "Lenth Plot for W Model")
```

**Method 8 Sequential Split Plot Method**
```{r W Model and S-W Model}
#-----------------------------------------------------------
#S Model - SP Factors (WP main effects, SP main effects, 
#2-way interactions within WP and SP and 2-way interactions 
# with WP Factors)
formula_S <- as.formula(paste("Y_S ~ (", paste(linear_terms, 
                                  collapse = " + "),")^2"))
#Create model matrix for S Model
Y_S <- Ys_data$Y_S
X_S <- model.matrix(formula_S, data = Ys_data)
#-----------------------------------------------------------
#W Model - WP factors (main WP effects, 2-way interactions)
formula_W <- as.formula(paste("Y_W ~ (", 
              paste(WP_factors, collapse = " + "),")^2"))

#Create model matrix for W Model
X_W <- model.matrix(formula_W, data = Yw_data)
# Replicate each row 4 times and drop row 20.
X_W <- X_W[rep(1:nrow(X_W), each = 4), ][-20, ]

Y_W <- rep(Yw_data$Y_W, each = 4)[-20]
df_W <- data.frame(Y_W, X_W)

cat("Linear Model Fit for W Model (OLS)", "\n")
W_Model <- summary(lm(formula_W, data = Yw_data))
W_Model
#------------------------------------------------------------
#S-W Model by Satterwaithe
#Create model matrix for S-W Model
X_SW <- X_S[, SP_effects_names]
Y_SW <- Y_S - Y_W
df_SW <- data.frame(Y_SW, X_SW, check.names = FALSE)
  formula_SW <- as.formula(
  "Y_SW ~ D + R + `D:R` + `T:D` + `T:R` + `P:D` + `P:R` + `S:D` + `S:R`")
SW_Model <-lm(formula_SW, data = df_SW)

cat("\n")
cat("Linear Model Fit for SW1 Model (OLS)", "\n")
SW_Model_summary <- summary(SW_Model)
SW_Model_summary
#-------------------------------------------------------------

```

**SSPD Method Model Adequacy Test**
```{r SSPD Method Model Adequacy Test}

# Perform F-test using ANOVA
# model1 is the reduced model (SW Model)
# model 2 is the full model (S Model)

# SW Model Comparison
Y_SW <- Y_S - Y_W

#$Model 1 - Reduced Model
df_SW1 <- data.frame(Y_SW, X_S, check.names = FALSE)
formula_SW1 <- as.formula(
  "Y_SW ~ D + R + `D:R` + `T:D` + `T:R` + `P:D` + `P:R` + `S:D` + `S:R`")

SW_Model_1 <-lm(formula_SW1, data = df_SW1)

#Model 2 - Full Model
df_SW2 <- data.frame(Y_SW, X_S, check.names = FALSE)
formula_SW2 <- as.formula(paste("Y_SW ~ (", paste(linear_terms, 
                               collapse = " + "),")^2"))
SW_Model_2 <-lm(formula_SW2, data = df_SW2)

# Summaries
cat("\n")
cat("Linear Model Fit for SW1 Model (OLS)", "\n")
SW_Model_1_summary <- summary(SW_Model_1)
SW_Model_1_summary

cat("\n")
cat("Linear Model Fit for SW2 Model (OLS)", "\n")
SW_Model_2_summary <- summary(SW_Model_2)
SW_Model_2_summary


model_adequacy <- anova(SW_Model_1, SW_Model_2)
print(model_adequacy)


```

